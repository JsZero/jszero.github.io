<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Java-JVM原理 - braoqq&#039;s blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="braoqq&#039;s blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="braoqq&#039;s blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Java内存模型 JMM TODO  JVM内存区域    * 程序计数器：线程私有的，jvm通过改变计数器的值来选取下一条需要执行的字节码指令，唯一一个没有规定任何OutOfMemoryError情况的区域          * Java虚拟机栈：线程私有的，每个方法执行时创建栈帧，方法被调用就是栈帧在栈中从入栈到出栈的过程。栈帧的组成部分如下，         * 局部变量表：存放编译期可知的"><meta property="og:type" content="blog"><meta property="og:title" content="Java-JVM原理"><meta property="og:url" content="https://jszero.github.io/2025/03/30/Java-JVM%E5%8E%9F%E7%90%86/"><meta property="og:site_name" content="braoqq&#039;s blog"><meta property="og:description" content="Java内存模型 JMM TODO  JVM内存区域    * 程序计数器：线程私有的，jvm通过改变计数器的值来选取下一条需要执行的字节码指令，唯一一个没有规定任何OutOfMemoryError情况的区域          * Java虚拟机栈：线程私有的，每个方法执行时创建栈帧，方法被调用就是栈帧在栈中从入栈到出栈的过程。栈帧的组成部分如下，         * 局部变量表：存放编译期可知的"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://jszero.github.io/images/gallery/posts-content/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.webp"><meta property="og:image" content="https://jszero.github.io/images/gallery/posts-content/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.webp"><meta property="og:image" content="https://jszero.github.io/images/gallery/posts-content/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB.webp"><meta property="og:image" content="https://jszero.github.io/images/gallery/posts-content/Serial%E5%92%8CSerialOld%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.webp"><meta property="og:image" content="https://jszero.github.io/images/gallery/posts-content/ParNew%E5%92%8CSerialOld%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.webp"><meta property="og:image" content="https://jszero.github.io/images/gallery/posts-content/Serial%E5%92%8CSerialOld%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.webp"><meta property="og:image" content="https://jszero.github.io/images/gallery/posts-content/ParallelScavenge%E5%92%8CParallelOld%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.webp"><meta property="og:image" content="https://jszero.github.io/images/gallery/posts-content/G1%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.webp"><meta property="article:published_time" content="2025-03-30T09:56:13.000Z"><meta property="article:modified_time" content="2025-05-07T14:30:03.251Z"><meta property="article:author" content="jszero"><meta property="article:tag" content="Interview"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/images/gallery/posts-content/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.webp"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://jszero.github.io/2025/03/30/Java-JVM%E5%8E%9F%E7%90%86/"},"headline":"Java-JVM原理","image":["https://jszero.github.io/images/gallery/posts-content/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.webp","https://jszero.github.io/images/gallery/posts-content/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.webp","https://jszero.github.io/images/gallery/posts-content/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB.webp","https://jszero.github.io/images/gallery/posts-content/Serial%E5%92%8CSerialOld%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.webp","https://jszero.github.io/images/gallery/posts-content/ParNew%E5%92%8CSerialOld%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.webp","https://jszero.github.io/images/gallery/posts-content/Serial%E5%92%8CSerialOld%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.webp","https://jszero.github.io/images/gallery/posts-content/ParallelScavenge%E5%92%8CParallelOld%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.webp","https://jszero.github.io/images/gallery/posts-content/G1%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.webp"],"datePublished":"2025-03-30T09:56:13.000Z","dateModified":"2025-05-07T14:30:03.251Z","author":{"@type":"Person","name":"jszero"},"publisher":{"@type":"Organization","name":"braoqq's blog","logo":{"@type":"ImageObject","url":"https://jszero.github.io/img/logo2.svg"}},"description":"Java内存模型 JMM TODO  JVM内存区域    * 程序计数器：线程私有的，jvm通过改变计数器的值来选取下一条需要执行的字节码指令，唯一一个没有规定任何OutOfMemoryError情况的区域          * Java虚拟机栈：线程私有的，每个方法执行时创建栈帧，方法被调用就是栈帧在栈中从入栈到出栈的过程。栈帧的组成部分如下，         * 局部变量表：存放编译期可知的"}</script><link rel="canonical" href="https://jszero.github.io/2025/03/30/Java-JVM%E5%8E%9F%E7%90%86/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/idea.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-78QW9ZHBDP" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'G-78QW9ZHBDP');</script><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }
          Array
              .from(document.querySelectorAll('.tab-content'))
              .forEach($tab => {
                  $tab.classList.add('is-hidden');
              });
          Array
              .from(document.querySelectorAll('.tabs li'))
              .forEach($tab => {
                  $tab.classList.remove('is-active');
              });
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo2.svg" alt="braoqq&#039;s blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">时间轴</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-03-30T09:56:13.000Z" title="3/30/2025, 5:56:13 PM">2025-03-30</time>发表</span><span class="level-item"><time dateTime="2025-05-07T14:30:03.251Z" title="5/7/2025, 10:30:03 PM">2025-05-07</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Interview/">Interview</a><span> / </span><a class="link-muted" href="/categories/Interview/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></span><span class="level-item">32 分钟读完 (大约4850个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Java-JVM原理</h1><div class="content"><h1 id="Java内存模型-JMM"><a href="#Java内存模型-JMM" class="headerlink" title="Java内存模型 JMM"></a>Java内存模型 JMM</h1><p>TODO</p>
<h1 id="JVM内存区域"><a href="#JVM内存区域" class="headerlink" title="JVM内存区域"></a>JVM内存区域</h1><p><img src="/images/gallery/posts-content/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.webp" alt="Java虚拟机运行时数据区"></p>
<ul>
<li><p><strong>程序计数器</strong>：线程私有的，jvm通过改变计数器的值来选取下一条需要执行的字节码指令，唯一一个没有规定任何OutOfMemoryError情况的区域</p>
</li>
<li><p><strong>Java虚拟机栈</strong>：线程私有的，每个方法执行时创建栈帧，方法被调用就是栈帧在栈中从入栈到出栈的过程。栈帧的组成部分如下，</p>
<ul>
<li>局部变量表：存放编译期可知的各种jvm基本数据类型、对象引用。todo 待完善</li>
<li>操作数栈：</li>
<li>动态链接：</li>
<li>方法返回地址：</li>
</ul>
</li>
<li><p><strong>本地方法栈</strong>：线程私有的，本地（Native）方法所使用的栈</p>
</li>
<li><p><strong>Java堆</strong>：线程共享的，分配内存创建存储对象实例的主要内存区域。在即时编译（JIT）的栈上分配、标量替换等技术下，也可以分配在其他区域</p>
<ul>
<li><strong>分配缓冲区</strong>：即TLAB（Thread Local Allocation Buffer），用于优化内存分配速度，避免线程并行导致分配内存冲突而提前为线程预留内存</li>
</ul>
</li>
<li><p><strong>方法区</strong>：线程共享的，也称永久代，用于存储已被jvm加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。在jdk8以后被本地内存中实现的元空间（Meta-space）代替</p>
<ul>
<li><strong>运行时常量池</strong>：方法区的一部分。Class文件中除了类版本、字段、方法、接口等信息外，还有一项信息是常量池表，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中</li>
</ul>
</li>
<li><p><strong>直接内存</strong>：不是jvm运行时数据区的一部分，NIO中使用，基于Channel与Buffer的I&#x2F;O方式，直接分配堆外内存，避免java堆和Native堆之间的数据赋值，从而显著提升性能</p>
</li>
</ul>
<h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h1><h2 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h2><ul>
<li>new实例化类对象，读取或者设置类的静态字段（final修饰编译期把结果放入常量池的静态字段除外），调用一个类的静态方法时</li>
<li>对类型进行反射调用</li>
<li>当初始化子类的时候，发现父类还未初始化，会初始化父类</li>
<li>…</li>
</ul>
<h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><ol>
<li>加载</li>
<li>验证</li>
<li>准备</li>
<li>解析</li>
<li>初始化</li>
<li>使用</li>
<li>卸载：卸载的前提有3个<ol>
<li>该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象</li>
<li>该类没有在其他任何地方被引用</li>
<li>该类的类加载器的实例已被 GC</li>
</ol>
</li>
</ol>
<h2 id="类加载器机制"><a href="#类加载器机制" class="headerlink" title="类加载器机制"></a>类加载器机制</h2><p>三层类加载器、双亲委派的类加载架构</p>
<h3 id="类加载器（Class-Loader）"><a href="#类加载器（Class-Loader）" class="headerlink" title="类加载器（Class Loader）"></a>类加载器（Class Loader）</h3><ul>
<li><strong>启动类加载器（Bootstrap Class Loader）</strong>：C++语言编写，JVM的一部分。责加载存放在<code>&lt;JAVA_HOME&gt;\lib</code>目录，或者被-Xbootclasspath参数所指定的路径中存放的，而且是Java虚拟机能够识别的类库加载到虚拟机的内存中</li>
<li><strong>扩展类加载器（Extension Class Loader）</strong>：负责加载<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录中，或者被java.ext.dirs系统变量所指定的路径中所有的类库</li>
<li><strong>应用程序类加载器（Application Class Loader）</strong>：也称为“系统类加载器”。它负责加载用户类路径（ClassPath）上所有的类库，开发者同样可以直接在代码中使用这个类加载器</li>
</ul>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p><img src="/images/gallery/posts-content/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.webp" alt="类加载器双亲委派模型"><br><strong>双亲委派模型的工作过程</strong>：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载</p>
<h3 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h3><ul>
<li>线程上下文类加载器</li>
<li>SPI</li>
<li>OSGi</li>
</ul>
<h2 id="类的卸载条件"><a href="#类的卸载条件" class="headerlink" title="类的卸载条件"></a>类的卸载条件</h2><h1 id="对象的创建过程"><a href="#对象的创建过程" class="headerlink" title="对象的创建过程"></a>对象的创建过程</h1><ol>
<li>常量池中尝试定位类的符号引用，判断类是否被加载、解析和初始化过。如果没有先做类加载</li>
<li>为对象分配内存。内存规整使用“指针碰撞”，内存零散使用“空闲列表”。处理线程申请内存的冲突，可以选择使用cas失败重试或者TLAB</li>
<li>内存空间初始化为零值，（TLAB方式也可以提前到TLAB分配时进行）</li>
<li>初始化对象头信息，类的元数据信息、哈希码、对象的gc分代年龄。根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式</li>
<li>执行类构造函数创建实例</li>
</ol>
<h1 id="垃圾回收理论"><a href="#垃圾回收理论" class="headerlink" title="垃圾回收理论"></a>垃圾回收理论</h1><h2 id="判断对象是否应该被回收"><a href="#判断对象是否应该被回收" class="headerlink" title="判断对象是否应该被回收"></a>判断对象是否应该被回收</h2><ul>
<li><strong>引用计数法</strong>：引用一次计数+1。存在循环引用的问题，比如map大对象需要嵌套引用关系<ul>
<li>引用类型<ul>
<li>强引用</li>
<li>软引用</li>
<li>弱引用</li>
<li>虚引用</li>
</ul>
</li>
</ul>
</li>
<li><strong>可达性分析</strong>：通过GC Roots根据引用关系向下搜索，到达不了的对象就是需要被回收的<ul>
<li>可作为GC Roots的对象：<ul>
<li>虚拟机栈中引用的对象，比如参数、局部变量、临时变量等</li>
<li>类静态属性引用的变量</li>
<li>常量引用的对象</li>
<li>JNI引用的对象</li>
<li>sychronized同步锁持有的对象</li>
<li>…</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><ul>
<li><p><strong>分代收集理论</strong>：根据以下理论，一般将jvm堆划分成新生代和老年代，对不通的区域单独进行gc</p>
<ul>
<li>弱分代假说：绝大多数对象都是朝生夕灭的</li>
<li>强分代假说：熬过越多次垃圾回收的对象就越难被回收</li>
</ul>
</li>
<li><p><strong>标记-清除算法</strong>：标记阶段，标记所有需要回收的对象，回收阶段，统一回收掉所有被标记的对象。但是存在如下缺点</p>
<ul>
<li>当存在大量对象需要被回收时，标记和回收的效率随着对象增多而降低</li>
<li>内存空间碎片化，大对象无法分配足够的连续内存，而引发额外的gc动作</li>
</ul>
</li>
<li><p><strong>标记-复制算法</strong>：也叫做复制算法。针对的新生代对象的存亡特征：朝生夕灭。将堆划分成一块Eden空间和两块较小的Survivor空间（默认8:1），每次只用一块Eden空间和一块Survivor空间，每次gc时将存活的对象复制到剩下的一块Survivor空间中，清除Eden空间和使用过的Survivor空间。Survivor空间不足一次gc的时候，一般会用老年代做分配的担保</p>
</li>
<li><p><strong>标记-整理算法</strong>：针对老年代独享的存亡特征：难以回收。标记阶段同“标记-清除算法”，清理阶段让所有存活的对象都向内存空间的一端移动，然后直接清理掉边界以外的内存</p>
<blockquote>
<p>注：标记-清除算法所带来的jvm停顿会更小，但是由于内存分配和访问的频率比gc要高，标记-整理算法的吞吐量会更高。所以关注延迟的CMS是基于标记-清除算法的，关注吞吐的Parallel Scavenge是基于标记-整理算法的</p>
</blockquote>
</li>
</ul>
<h2 id="回收相关算法细节"><a href="#回收相关算法细节" class="headerlink" title="回收相关算法细节"></a>回收相关算法细节</h2><ul>
<li><strong>根结点枚举</strong>：方法区比较大，查找GC Root耗时较长。使用OopMap直接存放对象引用位置，提高查找效率</li>
<li><strong>安全点</strong>：在执行到“长时间执行”的位置生成OopMap，这些位置被称为安全点。这些位置是执行序列复用的地方，比如方法调用、循环跳转、异常跳转<ul>
<li>线程执行到安全点如何停顿：抢占式中断，一般不用。主动式中断，设置标志位等待线程运行到安全点自己主动挂起</li>
</ul>
</li>
<li><strong>安全区域</strong>：未分配到时间分片的线程，如sleep或者blocked状态的线程。这种能确保在某一段代码中，引用关系不会发生变化的区域，被称为安全区域</li>
<li><strong>记忆集与卡表</strong>：新生代和老年代之间可能存在引用关系，为了避免对新生代回收时扫描整个老年代，在新生代中建立了记忆集的数据结构。<strong>卡表</strong>是记忆集的一种具体实现，定义了记忆集的记录精度，与堆内存的映射关系等，卡表标识的每一个内存块叫卡页，存在跨代引用会将卡页刷脏，脏页在回收时是需要被扫描的</li>
<li><strong>写屏障</strong>：写屏障可以看作在虚拟机层面对“引用类型字段赋值”这个动作的AOP切面，在这个切面上可以维护卡表状态</li>
<li><strong>并发的可达性分析</strong>：使用<strong>三色标记法</strong>实现<ul>
<li>颜色种类<ul>
<li>白色：对象尚未被垃圾收集器访问过。分析开始所有对象是白色，分析结束只有不可达的对象是白色</li>
<li>黑色：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。黑色对象不可能指向白色对象</li>
<li>灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过</li>
</ul>
</li>
<li>如何避免对象误标记：用户线程和标记线程并发运行，可能标记过后节点是白色但是新增了引用关系应该为黑色，如果不处理，该节点会被错误地回收掉<ul>
<li>误标记出现条件<ul>
<li>增加了一条或者多条从黑色对象到白色对象的引用</li>
<li>删除了全部从灰色对象到白色对象的直接或间接引用</li>
</ul>
</li>
<li>解决方案：（两种方案任选其一）<ol>
<li>增量更新（Incremental Update）：新增黑色指向白色的引用时，记录这个引用关系。并发扫描结束之后，再以黑色对象为根重新扫描一次。CMS的实现方式</li>
<li>原始快照（SATB，Snapshot At The Beginning）：删除灰色指向白色的引用时，记录这个引用关系。并发扫描结束之后，再以灰色对象为根重新扫描一次。G1、Shenandoah的实现方式</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h1><h2 id="垃圾回收器之间的组合关系"><a href="#垃圾回收器之间的组合关系" class="headerlink" title="垃圾回收器之间的组合关系"></a>垃圾回收器之间的组合关系</h2><p><img src="/images/gallery/posts-content/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB.webp" alt="垃圾回收器之间的组合关系"></p>
<h2 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h2><p><img src="/images/gallery/posts-content/Serial%E5%92%8CSerialOld%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.webp" alt="Serial/Serial Old收集器运行示意图"><br><strong>特点</strong>：gc时必须暂停其他工作线程直至gc结束<br><strong>优点</strong>：简单高效，额外内存开销小，适用于资源受限的环境。客户端模式下可以使用，比如桌面应用<br><strong>缺点</strong>：停顿时间较长，体验较差</p>
<h2 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h2><p><img src="/images/gallery/posts-content/ParNew%E5%92%8CSerialOld%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.webp" alt="ParNew/Serial Old收集器运行示意图"><br><strong>特点</strong>：Serial收集器的多线程并行版本。<strong>除了Serial收集器外，目前只有它能与CMS收集器配合工作</strong></p>
<h2 id="Parallel-Scanvenge收集器"><a href="#Parallel-Scanvenge收集器" class="headerlink" title="Parallel Scanvenge收集器"></a>Parallel Scanvenge收集器</h2><p><strong>特点</strong>：新生代收集器，基于标记-复制算法实现，也是能并行收集的多线程收集器。该收集器目标是达到一个可控制的吞吐量。-XX：MaxGCPauseMillis设置最大停顿时间，设置越小相对地gc越频繁，-XX：GCTimeRatio设置gc时间占总时间的比例。除此之外，-XX：+UseAdaptiveSizePolicy可以设置自适应调节，无需指定Eden，Survivor区大小，收集器会自动调节以做到最优吞吐</p>
<h2 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h2><p><img src="/images/gallery/posts-content/Serial%E5%92%8CSerialOld%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.webp" alt="Serial/Serial Old收集器运行示意图"><br><strong>特点</strong>：是Serial收集器的老年代版本，单线程收集器，使用标记-整理算法。该收集器的主要意义也是供客户端模式下的JVM使用。服务端模式下，有两种用途，一是JDK 5以及之前的版本中与Parallel Scavenge收集器搭配，二是另外一种就是作为CMS收集器发生失败时的后备预案，在并发收集发生Concurrent Mode Failure时使用</p>
<h2 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h2><p><img src="/images/gallery/posts-content/ParallelScavenge%E5%92%8CParallelOld%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.webp" alt="Parallel Scavenge/Parallel Old收集器运行示意图"><br><strong>特点</strong>：Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑这个组合</p>
<h2 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h2><p><strong>特点</strong>：一种以获取最短回收停顿时间为目标的收集器，基于标记-清除算法实现的<br><strong>步骤</strong>：<br>    1. <strong>初始标记</strong>：标记一下GC Roots能直接关联到的对象，停顿较短<br>    2. <strong>并发标记</strong>：从GC Roots的直接关联对象开始遍历整个对象图，与用户线程并发<br>    3. <strong>重新标记</strong>：为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，停顿较长<br>    4. <strong>并发清除</strong>：清理删除掉标记阶段判断的已经死亡的对象，与用户线程并发</p>
<blockquote>
<p>初始标记、重新标记两步需要“Stop The World”</p>
</blockquote>
<p><strong>优点</strong>：</p>
<ul>
<li><strong>并发收集，低停顿</strong></li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>对处理器资源非常敏感</strong>。在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分cpu资源而导致应用程序变慢，降低总吞吐量</li>
<li><strong>无法处理“浮动垃圾”</strong>，可能出现“Concurrent Mode Failure”失败进而导致另一次完全“Stop The World”的Full GC的产生。CMS运行期间预留的内存无法满足程序分配新对象，即“Concurrent Mode Failure”，需要临时启用Serial Old收集器来重新进行老年代的垃圾收集<blockquote>
<p><strong>浮动垃圾</strong>：并发标记和并发清理阶段，用户线程还在继续运行，程序在运行不断产生新的垃圾对象，但这部分垃圾无法在当次GC被标记处理，只好留待下一次GC时再清理。这一部分垃圾就称为“浮动垃圾”</p>
</blockquote>
</li>
<li><strong>收集结束时会有大量空间碎片产生</strong>。碎片过多时，往往会出现老年代还有很多剩余空间，但无法找到足够大的连续空间来分配当前对象，而不得不提前触发一次Full GC的情况。-XX：+UseCMS-CompactAtFullCollection参数可以指定full gc时整理内存碎片，-XX：CMSFullGCsBefore-Compaction参数可以指定进行n次不整合碎片的full gc之后，下次full gc之前先整理碎片</li>
</ul>
<h2 id="Garbage-First收集器（G1）"><a href="#Garbage-First收集器（G1）" class="headerlink" title="Garbage First收集器（G1）"></a>Garbage First收集器（G1）</h2><p><img src="/images/gallery/posts-content/G1%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.webp" alt="G1收集器运行示意图"><br><strong>特点</strong>：基于Region的内存布局形式，面向服务端应用的垃圾收集器。建立起“停顿时间模型”，把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region根据需要，扮演新生代的Eden空间、Survivor空间，或老年代空间。将Region作为单次回收的最小单元，后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间（-XX：MaxGCPauseMillis），优先处理回收价值收益最大的那些Region。每个Region都维护有自己的记忆集，G1至少要耗费大约相当于Java堆容量10%至20%的额外内存来维持收集器工作</p>
<blockquote>
<p><strong>停顿时间模型</strong>：能够支持指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒这样的目标</p>
</blockquote>
<p><strong>步骤</strong>：<br>    1. <strong>初始标记</strong>：标记一下GC Roots能直接关联到的对象，停顿较短<br>    2. <strong>并发标记</strong>：从GC Roots的直接关联对象开始遍历整个对象图，与用户线程并发<br>    3. <strong>最终标记</strong>：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录，停顿较短<br>    4. <strong>筛选回收</strong>：更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据期望的停顿时间制定回收计划，把决定回收的部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间，涉及存活对象的移动，必须暂停用户线程</p>
<blockquote>
<p>G1收集器除了并发标记外，其余阶段也是要完全暂停用户线程的，换言之，它并非纯粹地追求低延迟，官方给它设定的目标是在延迟可控的情况下获得尽可能高的吞吐量</p>
</blockquote>
<p><strong>优点</strong>：</p>
<ul>
<li>可以指定最大停顿时间、分Region内存布局、收益动态确定回收集合</li>
<li>从整体来看是基于“标记-整理”算法实现的收集器，但从局部（两个Region之间）上看又是基于“标记-复制”算法实现，不会产生内存空间碎片</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>额外内存占用和执行负载比CMS要高（Region粒度的卡表，以及卡表更复杂的维护）</li>
</ul>
</div><div class="article-licensing box"><div class="licensing-title"><p>Java-JVM原理</p><p><a href="https://jszero.github.io/2025/03/30/Java-JVM原理/">https://jszero.github.io/2025/03/30/Java-JVM原理/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>jszero</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2025-03-30</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2025-05-07</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Interview/">Interview</a></div><div class="a2a_kit a2a_kit_size_32 a2a_default_style"><a class="a2a_dd" target="_blank" rel="noopener" href="https://www.addtoany.com/share"></a><a class="a2a_button_twitter"></a><a class="a2a_button_wechat"></a><a class="a2a_button_sina_weibo"></a><a class="a2a_button_email"></a></div><script src="https://static.addtoany.com/menu/page.js" defer></script></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2025/04/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">操作系统</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2025/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86%E6%8B%93%E6%89%91/"><span class="level-item">计算机知识拓扑</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content" id="waline-thread"></div><script src="https://cdn.jsdelivr.net/npm/@waline/client@1.5.4/dist/Waline.min.js"></script><script>Waline({
            el: '#waline-thread',
            serverURL: "https://blog.comment.bravoqq.tech",
            path: window.location.pathname,
            lang: "zh-CN",
            visitor: false,
            emoji: ["//unpkg.com/@waline/emojis@1.0.1/weibo"],
            dark: "auto",
            meta: ["nick","mail","link"],
            requiredMeta: [],
            login: "enable",
            
            pageSize: 10,
            
            
            math: false,
            copyright: true,
            locale: {"placeholder":"Comment here..."},
        });</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://octodex.github.com/images/mummytocat.gif" alt="小七"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">小七</p><p class="is-size-6 is-block">你就学吧，总能学会的</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Beijing, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">32</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">16</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">16</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/JsZero" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/JsZero"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="X" href="https://x.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Database/"><span class="level-start"><span class="level-item">Database</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Interview/"><span class="level-start"><span class="level-item">Interview</span></span><span class="level-end"><span class="level-item tag">20</span></span></a><ul><li><a class="level is-mobile" href="/categories/Interview/%E7%9F%A5%E8%AF%86%E6%8B%93%E6%89%91/"><span class="level-start"><span class="level-item"># 知识拓扑</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Interview/%E4%B8%AD%E9%97%B4%E4%BB%B6/"><span class="level-start"><span class="level-item">中间件</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Interview/%E5%A4%A7%E6%95%B0%E6%8D%AE/"><span class="level-start"><span class="level-item">大数据</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Interview/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">操作系统</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Interview/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"><span class="level-start"><span class="level-item">架构设计</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Interview/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">编程语言</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Interview/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="level-start"><span class="level-item">设计模式</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Interview/%E9%A1%B9%E7%9B%AE%E5%9B%9E%E9%A1%BE/"><span class="level-start"><span class="level-item">项目回顾</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Interview/%F0%9F%8D%BA-Code-Interview/"><span class="level-start"><span class="level-item">🍺 Code Interview</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/category/"><span class="level-start"><span class="level-item">category</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"><span class="level-start"><span class="level-item">分布式</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"><span class="level-start"><span class="level-item">大数据</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/Spark/"><span class="level-start"><span class="level-item">Spark</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E8%B0%83%E5%BA%A6%E6%9C%8D%E5%8A%A1/"><span class="level-start"><span class="level-item">调度服务</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Akka/"><span class="tag">Akka</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Database/"><span class="tag">Database</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Interview/"><span class="tag">Interview</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MySQL/"><span class="tag">MySQL</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Spark/"><span class="tag">Spark</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/leetcode/"><span class="tag">leetcode</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tag/"><span class="tag">tag</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"><span class="tag">中间件</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"><span class="tag">分布式</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><span class="tag">多线程</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"><span class="tag">大数据</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="tag">操作系统</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"><span class="tag">架构设计</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="tag">设计模式</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%B0%83%E5%BA%A6/"><span class="tag">调度</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%A1%B9%E7%9B%AE%E5%9B%9E%E9%A1%BE/"><span class="tag">项目回顾</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2025/08/"><span class="level-start"><span class="level-item">八月 2025</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/06/"><span class="level-start"><span class="level-item">六月 2025</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/05/"><span class="level-start"><span class="level-item">五月 2025</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/04/"><span class="level-start"><span class="level-item">四月 2025</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/03/"><span class="level-start"><span class="level-item">三月 2025</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/02/"><span class="level-start"><span class="level-item">二月 2025</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/08/"><span class="level-start"><span class="level-item">八月 2024</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/07/"><span class="level-start"><span class="level-item">七月 2024</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/07/"><span class="level-start"><span class="level-item">七月 2022</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-08-18T15:38:15.000Z">2025-08-18</time></p><p class="title"><a href="/2025/08/18/Spark%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-Shuffle/">Spark源码解析 - Shuffle</a></p><p class="categories"><a href="/categories/category/">category</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-08-09T16:17:21.000Z">2025-08-10</time></p><p class="title"><a href="/2025/08/10/Spark%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/">Spark源码解析 - 分布式计算执行流程</a></p><p class="categories"><a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a> / <a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/Spark/">Spark</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-08-09T09:23:32.000Z">2025-08-09</time></p><p class="title"><a href="/2025/08/09/Spark%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-Spark-SQL%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B/">Spark源码解析 - Spark SQL处理过程</a></p><p class="categories"><a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a> / <a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/Spark/">Spark</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-08-09T00:46:06.000Z">2025-08-09</time></p><p class="title"><a href="/2025/08/09/Spark%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-spark-submit%E6%8F%90%E4%BA%A4%E8%BF%87%E7%A8%8B/">Spark源码解析 - spark-submit提交过程</a></p><p class="categories"><a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a> / <a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/Spark/">Spark</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-06-08T03:26:34.000Z">2025-06-08</time></p><p class="title"><a href="/2025/06/08/Hadoop%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/">Hadoop常见问题</a></p><p class="categories"><a href="/categories/Interview/">Interview</a> / <a href="/categories/Interview/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a></p></div></article></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Java内存模型-JMM"><span class="level-left"><span class="level-item">1</span><span class="level-item">Java内存模型 JMM</span></span></a></li><li><a class="level is-mobile" href="#JVM内存区域"><span class="level-left"><span class="level-item">2</span><span class="level-item">JVM内存区域</span></span></a></li><li><a class="level is-mobile" href="#类加载机制"><span class="level-left"><span class="level-item">3</span><span class="level-item">类加载机制</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#类加载时机"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">类加载时机</span></span></a></li><li><a class="level is-mobile" href="#类的生命周期"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">类的生命周期</span></span></a></li><li><a class="level is-mobile" href="#类加载器机制"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">类加载器机制</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#类加载器（Class-Loader）"><span class="level-left"><span class="level-item">3.3.1</span><span class="level-item">类加载器（Class Loader）</span></span></a></li><li><a class="level is-mobile" href="#双亲委派模型"><span class="level-left"><span class="level-item">3.3.2</span><span class="level-item">双亲委派模型</span></span></a></li><li><a class="level is-mobile" href="#破坏双亲委派模型"><span class="level-left"><span class="level-item">3.3.3</span><span class="level-item">破坏双亲委派模型</span></span></a></li></ul></li><li><a class="level is-mobile" href="#类的卸载条件"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">类的卸载条件</span></span></a></li></ul></li><li><a class="level is-mobile" href="#对象的创建过程"><span class="level-left"><span class="level-item">4</span><span class="level-item">对象的创建过程</span></span></a></li><li><a class="level is-mobile" href="#垃圾回收理论"><span class="level-left"><span class="level-item">5</span><span class="level-item">垃圾回收理论</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#判断对象是否应该被回收"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">判断对象是否应该被回收</span></span></a></li><li><a class="level is-mobile" href="#垃圾回收算法"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">垃圾回收算法</span></span></a></li><li><a class="level is-mobile" href="#回收相关算法细节"><span class="level-left"><span class="level-item">5.3</span><span class="level-item">回收相关算法细节</span></span></a></li></ul></li><li><a class="level is-mobile" href="#垃圾回收器"><span class="level-left"><span class="level-item">6</span><span class="level-item">垃圾回收器</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#垃圾回收器之间的组合关系"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">垃圾回收器之间的组合关系</span></span></a></li><li><a class="level is-mobile" href="#Serial收集器"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">Serial收集器</span></span></a></li><li><a class="level is-mobile" href="#ParNew收集器"><span class="level-left"><span class="level-item">6.3</span><span class="level-item">ParNew收集器</span></span></a></li><li><a class="level is-mobile" href="#Parallel-Scanvenge收集器"><span class="level-left"><span class="level-item">6.4</span><span class="level-item">Parallel Scanvenge收集器</span></span></a></li><li><a class="level is-mobile" href="#Serial-Old收集器"><span class="level-left"><span class="level-item">6.5</span><span class="level-item">Serial Old收集器</span></span></a></li><li><a class="level is-mobile" href="#Parallel-Old收集器"><span class="level-left"><span class="level-item">6.6</span><span class="level-item">Parallel Old收集器</span></span></a></li><li><a class="level is-mobile" href="#CMS收集器"><span class="level-left"><span class="level-item">6.7</span><span class="level-item">CMS收集器</span></span></a></li><li><a class="level is-mobile" href="#Garbage-First收集器（G1）"><span class="level-left"><span class="level-item">6.8</span><span class="level-item">Garbage First收集器（G1）</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo2.svg" alt="braoqq&#039;s blog" height="28"></a><p class="is-size-7"><span>&copy; 2025 jszero</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><script src="https://cdn.jsdelivr.net/npm/mermaid@7.1.2/dist/mermaid.min.js"></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>